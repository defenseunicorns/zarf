---
title: Packages
sidebar:
  order: 20
---

Zarf offers a comprehensive solution for deploying system software or capabilities while fully disconnected. This is accomplished through the use of a single tarball archive, which includes all necessary components and is defined by a `zarf.yaml` file.

Zarf packages are created while you are connected to internet or intranet resources defined in a Zarf package configuration.  This allows these resources to be pulled and stored within a package archive and be deployed on disconnected systems without requiring a connection to the outside world.

The `zarf.yaml` file also defines declarative instructions for the deployment of package capabilities, which are automatically executed on package deployment and are represented in code. This ensures reproducibility across different systems without the need for manual configuration.

Zarf packages consist of functional blocks, known as components. Components can be optional, providing greater flexibility in package usage. Further details on components can be found on the [Zarf Components](/ref/components/) page.

## Types of Zarf Packages

There are two types of Zarf packages, the `ZarfInitConfig` and the `ZarfPackageConfig`, which are distinguished by the `kind:` field and specified in the `zarf.yaml` file.

Throughout the rest of the documentation, we will refer to the `ZarfInitConfig` as an `init config` package or `init` package, and to the `ZarfPackageConfig` as simply a "package".

### `ZarfInitConfig`

The init package is used to initialize a cluster, making it ready for deployment of other Zarf packages. It must be executed once on each cluster that you want to deploy another package onto, even if multiple clusters share the same host.

During the initialization process, Zarf will seed your cluster with a container registry to store images that other packages may require. Additionally, the init package has the option to deploy other features to your cluster, such as a Git server to manage your repositories or a PLG logging stack that allows you to monitor the applications running on your cluster. For additional information on the init package, we provide detailed documentation on the Zarf ['init' package page](/ref/init-package/).

#### Using the init-package

To initialize your cluster, you need to run the command `zarf init`. This command will search for a file with the specific naming convention: `zarf-init-{ARCHITECTURE}-{VERSION}.tar.zst`. The architecture must match that of the cluster you are deploying to. If you are deploying to a cluster with a different architecture, you will need to specify the name of the architecture you are deploying on with the `-a` flag. For example, if you are on an arm64 machine but are deploying on an amd64 machine, you will run `zarf init -a amd64`.

You do not need to create init configs by yourself unless you want to customize how your cluster is installed/configured. For example, if you want to use the init process to install a specifically configured K3s cluster onto your host machine, you can create a specific package to do that before running the init package.

### `ZarfPackageConfig`

`ZarfPackageConfig` refers to any package that is not an init package and is used to define specific capabilities that you want to deploy onto your initialized cluster.

To deploy a Zarf Package, you can use the command `zarf package deploy`. This will prompt you to select from all of the files in your current directory that match the name `zarf-package-*.tar.zst`. Alternatively, if you already know which package you want to deploy, you can simply use the command `zarf package deploy {PACKAGE_NAME}`.

During the deployment process, Zarf will leverage the infrastructure created during the 'init' process (such as the Docker registry and Git server) to push all the necessary images and repositories required for the package to operate.

## Differential Packages

If you already have a Zarf package and you want to create an updated package you would normally have to re-create the entire package from scratch, including things that might not have changed. Depending on your workflow, you may  want to create a package that only contains the artifacts that have changed since the last time you built your package. This can be achieved by using the `--differential` flag while running the `zarf package create` command. You can use this flag to point to an already built package you have locally or to a package that has been previously [published](/tutorials/7-publish-and-deploy#publish-package) to a registry.

## Package Sources

A source can be used with the following commands as their first argument:

- `zarf package deploy <source>`
- `zarf package inspect <source>`
- `zarf package remove <source>`
- `zarf package publish <source>`
- `zarf package pull <source>`
- `zarf package mirror-resources <source>`

Zarf currently supports consuming packages from the following sources:

### Local Tarball Path (`.tar` and `.tar.zst`)

A local tarball is the default output of `zarf package create` and is a package contained within a tarball with or without [Zstandard](https://facebook.github.io/zstd/) compression.  Compression is determined by a given package's [`metadata.uncompressed` key](https://docs.zarf.dev/docs/create-a-zarf-package/zarf-schema#metadata) within it's `zarf.yaml` package definition

### Split Tarball Path (`.part...`)

A split tarball is a local tarball that has been split into multiple parts so that it can fit on smaller media when traveling to a disconnected environment (i.e. on DVDs).  These packages are created by specifying a maximum number of megabytes with [`--max-package-size`](/commands/zarf_package_create/) on `zarf package create` and if the resulting tarball is larger than that size it will be split into chunks.

### Remote Tarball URL (`http://` and `https://` )

A remote tarball is a Zarf package tarball that is hosted on a web server that is accessible to the current machine.  By default Zarf does not provide a mechanism to place a package on a web server, but this is easy to orchestrate with other tooling such as uploading a package to a continuous integration system's artifact storage or to a repository's release page.

### Remote OCI Reference (`oci://`)

An OCI package is one that has been published to an OCI compatible registry using `zarf package publish` or the `-o` option on `zarf package create`.  These packages live within a given registry and you can learn more about them in our [Publish & Deploy Packages w/OCI Tutorial](/tutorials/7-publish-and-deploy/).

:::note

In addition to the traditional sources outlined above, there is also a special "Cluster" source available on `inspect` and `remove` that allows for referencing a deployed package via its name:

- `zarf package inspect <package name>`
- `zarf package remove <package name>`

Additionally, inspecting a package deployed to a cluster will not be able to show the package's SBOMs, as they are not currently persisted to the cluster.

:::

## Package create lifecycle
import Mermaid from "@components/Mermaid.astro";
import Details from "@components/Details.astro";

The following diagram shows the order of operations for the `zarf package create` command and the hook locations for [actions](/ref/actions).

<Details label="Lifecycle Diagram">
<Mermaid diagram={`
graph TD
    A1(set working directory)-->A2
    A2(parse zarf.yaml)-->A3
    A3(filter components by architecture)-->A4
    A4(detect init package)-->A5
    A5(handle deprecations)-->A6
    A6(parse component imports)-->A7
    A7(process create-time variables)-->A8
    A8(write build data and zarf.yaml)-->A9

    A9(run validations)-->A10
    A10(confirm package create):::prompt-->A11
    A11{Init package?}
    A11 -->|Yes| A12(add seed image)-->A13
    A11 -->|No| A13

    subgraph  ""
    A13(add each component)-->A13
    A13 --> A14(run each '.actions.onCreate.before'):::action-->A14
    A14 --> A15(load '.charts')-->A16
    A16(load '.files')-->A17
    A17(load '.dataInjections')-->A18
    A18(load '.manifests')-->A19
    A19(load '.repos')-->A20
    A20(run each '.actions.onCreate.after'):::action-->A20
    A20-->A21{Success?}
    A21-->|Yes|A22(run each\n'.actions.onCreate.success'):::action-->A22
    A21-->|No|A23(run each\n'.actions.onCreate.failure'):::action-->A23-->A999
    end

    A22-->A24(load all '.images')
    A24-->A25{Skip SBOM?}
    A25-->|Yes|A27
    A25-->|No|A26
    A26(generate SBOM)-->A27
    A27(reset working directory)-->A28
    A28(create package archive)-->A29
    A29{Is multipart?}
    A29-->|Yes|A30(split package archive)-->A31
    A29-->|No|A31
    A31(handle sbom view/out flags)

    A999[Abort]:::fail

    classDef prompt fill:#4adede,color:#000000
    classDef action fill:#bd93f9,color:#000000
    classDef fail fill:#aa0000
`}/>
</Details>
